# **Homework 1: Parallel computation of an inverted index using the Map-Reduce paradigm**

>This project consists in implementing a parallel program in `Pthreads` to find an inverted index for a set of input files.

To parallelize the processing of input files, there will be used the `Map-Reduce` model.
It works as follows:
1) The user requests processing of a set of files
2) This request is addressed to a main process (or thread)
3) The main process (or thread) assigns the files to some processes (or threads) of `Mapper` type.
4) A `Mapper` analyzes the files it is responsible for and generates some partial results of the form {key, value}.
5) After the Map operations have been executed, other processes (or threads) of `Reducer` type are responsible for aggregating the data generated by the `Mappers` and generating the final solution.

To realize the given requirements, I implemented the following functions: `"mapper_function"`, `"extract_words_from_file"`, `"transform_word"`, `"reducer_function"`, `"process_partial_list"`, `"write_output_files"`.

## **Table of contents**

1. ["main" function](#main-function)
2. [Mapper function](#mapper-function)
3. [Reducer function](#reducer-function)
4. [Additional functions](#additional-functions)

## **"main" function**

**1.** Process program's arguments: mappers number, reducers number, input file.

**2.** Initialize all the threadpool structure fields.

**3.** Create a queue of files that should be processed by the `Mapper` threads.

**4.** Create a queue of `M + R` thread structs that should be initialized, where M is the number of `Mapper` threads and R is the number of `Reducer` threads.

**5.** Initialize all the threads from the thread structs queue with their corresponding data.

**6.** Call the `pthread_join` function for all the threads.

**7.** Destroy the synchronization primitives (`mutex` and `barrier`) and free the allocated memory.

## **Mapper function**

**1.** Extracts the `thread_id` and `threadpool` pointer from the given argument.

**2.** Initialize thread's partial list of the form `map[word, [list of file ids]]`.

**3.** The threads dynamically extract and process the files information from the queue, until the queue becomes empty. Thread synchronization is performed by a mutex.

**4.** Each thread generates its own partial based on the files that it has processed.

**5.** When the queue becomes empty, the partial list of every thread is copied in the threadpool's array of partial lists to the index of `thread_id`.
Also, it's called `"pthread_barrier_wait(&tp->mappers_work_barrier)"` to signal that the current mapper thread has finished its work.

## **Reducer function**

**1.** Extracts the `thread_id` and `threadpool` pointer from the given argument.

**2.** Calls `"pthread_barrier_wait(&tp->mappers_work_barrier)"` in order to wait for the mapper threads to finish their work.

**3.** After the mappers have finished their work, every reducer thread starts aggregating the mappers' partial lists. Each thread continuously searches for an unvisited partial list of the `"partial_lists"` array until every partial list becomes visited. When a thread finds an unvisited list, it marks the list as being visited and processes it (copies the partial list into the final list). Every final list corresponds to a single letter of the english alphabet. E.g. `final_lists[i]` corresponds to the letter `'a' + i`. The vector of pairs from `final_list_t` structure, `word_list`, has the form `vector<pair<word, [list of file ids]>>`.

**4.** After the partial lists have been processed, the array `tp->finished_aggregation` contains the visited data of the reducer threads. If the thread with `thread_id` has finished the aggregation, it sets `tp->finished_aggregation[thread_id - tp->num_mapper_threads]` to true. Once all the threads have finished the aggregation, they start sorting the final lists.

**5.** Every final list corresponding to a letter will be sorted by a single thread that is dynamically chosen. When a thread learns that there are no more unvisited final lists, it sets `tp->reducers_finished_sorting[thread_id]` to true. When all threads set that to true, only one thread sets `"tp->started_writing"` to true and starts writing the files corresponding to every letter. In the meantime, the other reducer threads exit. After all the files have been written, the thread that wrote the files also exits.

## **Additional functions**

**Functions used by the Mapper threads:**
- `extract_words_from_file`: function that extracts all the unique words from a file and adds them in a partial list.
- `transform_word`: function that transforms words so that they contain only alphabetic characters.

**Functions used by the Reducer threads:**
- `process_partial_list`: function that handles the processing of the partial list corresponding to the given index argument.
- `write_output_files`: function that writes the files corresponding to all letters of the English alphabet.


<hr>



**(c) Racovcen Lauren»õiu**
